{"instruction": "Implement a function for: No description", "input": "Function name: __init__", "output": "def __init__(self):\n    self._data = ''\n    self._audio_path = ''\n    self._encrypted_audio_path = ''\n    self._decrypted_data = ''", "source": "audio_steganography.py"}
{"instruction": "Implement a function for: :param data: data to be embedded (str)\n:param audio_path: path of audio file(only .wav) (str)\n:param", "input": "Function name: encrypt", "output": "def encrypt(self, data, audio_path, encrypted_audio_path='song_embedded.wav'):\n    \"\"\"\n        :param data: data to be embedded (str)\n        :param audio_path: path of audio file(only .wav) (str)\n        :param encrypted_audio_path: path of encrypted audio file(only .wav) (str) (optional)\n        :return: None (encrypted audio file is saved)\n        \"\"\"\n    self._data = data\n    self._audio_path = audio_path\n    self._encrypted_audio_path = encrypted_audio_path\n    audio = wave.open(self._audio_path, 'rb')\n    frame_bytes = bytearray(list(audio.readframes(audio.getnframes())))\n    self._data = self._data + int((len(frame_bytes) - len(self._data) * 8 * 8) / 8) * '#'\n    bits = list(map(int, ''.join([bin(ord(i)).lstrip('0b').rjust(8, '0') for i in self._data])))\n    for i, bit in enumerate(bits):\n        frame_bytes[i] = frame_bytes[i] & 254 | bit\n    frame_modified = bytes(frame_bytes)\n    with wave.open(self._encrypted_audio_path, 'wb') as fd:\n        fd.setparams(audio.getparams())\n        fd.writeframes(frame_modified)\n    audio.close()", "source": "audio_steganography.py"}
{"instruction": "Implement a function for: :param audio_path: path of audio file(only .wav) (str)\n:return: data embedded in audio file (str)", "input": "Function name: decrypt", "output": "def decrypt(self, audio_path):\n    \"\"\"\n        :param audio_path: path of audio file(only .wav) (str)\n        :return: data embedded in audio file (str)\n        \"\"\"\n    self._data = ''\n    self._audio_path = audio_path\n    song = wave.open(self._audio_path, 'rb')\n    frame_bytes = bytearray(list(song.readframes(song.getnframes())))\n    extracted = [frame_bytes[i] & 1 for i in range(len(frame_bytes))]\n    string = ''.join((chr(int(''.join(map(str, extracted[i:i + 8])), 2)) for i in range(0, len(extracted), 8)))\n    self._data = string.split('###')[0]\n    song.close()\n    return self._data", "source": "audio_steganography.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: __init__", "output": "def __init__(self):\n    self._p = [608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731]\n    self._s = [[3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670, 3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374, 1667834072, 1901547113, 2757295779, 4103290238, 227898511, 1921955416, 1904987480, 2182433518, 2069144605, 3260701109, 2620446009, 720527379, 3318853667, 677414384, 3393288472, 3101374703, 2390351024, 1614419982, 1822297739, 2954791486, 3608508353, 3174124327, 2024746970, 1432378464, 3864339955, 2857741204, 1464375394, 1676153920, 1439316330, 715854006, 3033291828, 289532110, 2706671279, 2087905683, 3018724369, 1668267050, 732546397, 1947742710, 3462151702, 2609353502, 2950085171, 1814351708, 2050118529, 680887927, 999245976, 1800124847, 3300911131, 1713906067, 1641548236, 4213287313, 1216130144, 1575780402, 4018429277, 3917837745, 3693486850, 3949271944, 596196993, 3549867205, 258830323, 2213823033, 772490370, 2760122372, 1774776394, 2652871518, 566650946, 4142492826, 1728879713, 2882767088, 1783734482, 3629395816, 2517608232, 2874225571, 1861159788, 326777828, 3124490320, 2130389656, 2716951837, 967770486, 1724537150, 2185432712, 2364442137, 1164943284, 2105845187, 998989502, 3765401048, 2244026483, 1075463327, 1455516326, 1322494562, 910128902, 469688178, 1117454909, 936433444, 3490320968, 3675253459, 1240580251, 122909385, 2157517691, 634681816, 4142456567, 3825094682, 3061402683, 2540495037, 79693498, 3249098678, 1084186820, 1583128258, 426386531, 1761308591, 1047286709, 322548459, 995290223, 1845252383, 2603652396, 3431023940, 2942221577, 3202600964, 3727903485, 1712269319, 422464435, 3234572375, 1170764815, 3523960633, 3117677531, 1434042557, 442511882, 3600875718, 1076654713, 1738483198, 4213154764, 2393238008, 3677496056, 1014306527, 4251020053, 793779912, 2902807211, 842905082, 4246964064, 1395751752, 1040244610, 2656851899, 3396308128, 445077038, 3742853595, 3577915638, 679411651, 2892444358, 2354009459, 1767581616, 3150600392, 3791627101, 3102740896, 284835224, 4246832056, 1258075500, 768725851, 2589189241, 3069724005, 3532540348, 1274779536, 3789419226, 2764799539, 1660621633, 3471099624, 4011903706, 913787905, 3497959166, 737222580, 2514213453, 2928710040, 3937242737, 1804850592, 3499020752, 2949064160, 2386320175, 2390070455, 2415321851, 4061277028, 2290661394, 2416832540, 1336762016, 1754252060, 3520065937, 3014181293, 791618072, 3188594551, 3933548030, 2332172193, 3852520463, 3043980520, 413987798, 3465142937, 3030929376, 4245938359, 2093235073, 3534596313, 375366246, 2157278981, 2479649556, 555357303, 3870105701, 2008414854, 3344188149, 4221384143, 3956125452, 2067696032, 3594591187, 2921233993, 2428461, 544322398, 577241275, 1471733935, 610547355, 4027169054, 1432588573, 1507829418, 2025931657, 3646575487, 545086370, 48609733, 2200306550, 1653985193, 298326376, 1316178497, 3007786442, 2064951626, 458293330, 2589141269, 3591329599, 3164325604, 727753846, 2179363840, 146436021, 1461446943, 4069977195, 705550613, 3059967265, 3887724982, 4281599278, 3313849956, 1404054877, 2845806497, 146425753, 1854211946], [1266315497, 3048417604, 3681880366, 3289982499, 2909710000, 1235738493, 2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449, 422970021, 1963543593, 2690192192, 3826793022, 1062508698, 1531092325, 1804592342, 2583117782, 2714934279, 4024971509, 1294809318, 4028980673, 1289560198, 2221992742, 1669523910, 35572830, 157838143, 1052438473, 1016535060, 1802137761, 1753167236, 1386275462, 3080475397, 2857371447, 1040679964, 2145300060, 2390574316, 1461121720, 2956646967, 4031777805, 4028374788, 33600511, 2920084762, 1018524850, 629373528, 3691585981, 3515945977, 2091462646, 2486323059, 586499841, 988145025, 935516892, 3367335476, 2599673255, 2839830854, 265290510, 3972581182, 2759138881, 3795373465, 1005194799, 847297441, 406762289, 1314163512, 1332590856, 1866599683, 4127851711, 750260880, 613907577, 1450815602, 3165620655, 3734664991, 3650291728, 3012275730, 3704569646, 1427272223, 778793252, 1343938022, 2676280711, 2052605720, 1946737175, 3164576444, 3914038668, 3967478842, 3682934266, 1661551462, 3294938066, 4011595847, 840292616, 3712170807, 616741398, 312560963, 711312465, 1351876610, 322626781, 1910503582, 271666773, 2175563734, 1594956187, 70604529, 3617834859, 1007753275, 1495573769, 4069517037, 2549218298, 2663038764, 504708206, 2263041392, 3941167025, 2249088522, 1514023603, 1998579484, 1312622330, 694541497, 2582060303, 2151582166, 1382467621, 776784248, 2618340202, 3323268794, 2497899128, 2784771155, 503983604, 4076293799, 907881277, 423175695, 432175456, 1378068232, 4145222326, 3954048622, 3938656102, 3820766613, 2793130115, 2977904593, 26017576, 3274890735, 3194772133, 1700274565, 1756076034, 4006520079, 3677328699, 720338349, 1533947780, 354530856, 688349552, 3973924725, 1637815568, 332179504, 3949051286, 53804574, 2852348879, 3044236432, 1282449977, 3583942155, 3416972820, 4006381244, 1617046695, 2628476075, 3002303598, 1686838959, 431878346, 2686675385, 1700445008, 1080580658, 1009431731, 832498133, 3223435511, 2605976345, 2271191193, 2516031870, 1648197032, 4164389018, 2548247927, 300782431, 375919233, 238389289, 3353747414, 2531188641, 2019080857, 1475708069, 455242339, 2609103871, 448939670, 3451063019, 1395535956, 2413381860, 1841049896, 1491858159, 885456874, 4264095073, 4001119347, 1565136089, 3898914787, 1108368660, 540939232, 1173283510, 2745871338, 3681308437, 4207628240, 3343053890, 4016749493, 1699691293, 1103962373, 3625875870, 2256883143, 3830138730, 1031889488, 3479347698, 1535977030, 4236805024, 3251091107, 2132092099, 1774941330, 1199868427, 1452454533, 157007616, 2904115357, 342012276, 595725824, 1480756522, 206960106, 497939518, 591360097, 863170706, 2375253569, 3596610801, 1814182875, 2094937945, 3421402208, 1082520231, 3463918190, 2785509508, 435703966, 3908032597, 1641649973, 2842273706, 3305899714, 1510255612, 2148256476, 2655287854, 3276092548, 4258621189, 236887753, 3681803219, 274041037, 1734335097, 3815195456, 3317970021, 1899903192, 1026095262, 4050517792, 356393447, 2410691914, 3873677099, 3682840055], [3913112168, 2491498743, 4132185628, 2489919796, 1091903735, 1979897079, 3170134830, 3567386728, 3557303409, 857797738, 1136121015, 1342202287, 507115054, 2535736646, 337727348, 3213592640, 1301675037, 2528481711, 1895095763, 1721773893, 3216771564, 62756741, 2142006736, 835421444, 2531993523, 1442658625, 3659876326, 2882144922, 676362277, 1392781812, 170690266, 3921047035, 1759253602, 3611846912, 1745797284, 664899054, 1329594018, 3901205900, 3045908486, 2062866102, 2865634940, 3543621612, 3464012697, 1080764994, 553557557, 3656615353, 3996768171, 991055499, 499776247, 1265440854, 648242737, 3940784050, 980351604, 3713745714, 1749149687, 3396870395, 4211799374, 3640570775, 1161844396, 3125318951, 1431517754, 545492359, 4268468663, 3499529547, 1437099964, 2702547544, 3433638243, 2581715763, 2787789398, 1060185593, 1593081372, 2418618748, 4260947970, 69676912, 2159744348, 86519011, 2512459080, 3838209314, 1220612927, 3339683548, 133810670, 1090789135, 1078426020, 1569222167, 845107691, 3583754449, 4072456591, 1091646820, 628848692, 1613405280, 3757631651, 526609435, 236106946, 48312990, 2942717905, 3402727701, 1797494240, 859738849, 992217954, 4005476642, 2243076622, 3870952857, 3732016268, 765654824, 3490871365, 2511836413, 1685915746, 3888969200, 1414112111, 2273134842, 3281911079, 4080962846, 172450625, 2569994100, 980381355, 4109958455, 2819808352, 2716589560, 2568741196, 3681446669, 3329971472, 1835478071, 660984891, 3704678404, 4045999559, 3422617507, 3040415634, 1762651403, 1719377915, 3470491036, 2693910283, 3642056355, 3138596744, 1364962596, 2073328063, 1983633131, 926494387, 3423689081, 2150032023, 4096667949, 1749200295, 3328846651, 309677260, 2016342300, 1779581495, 3079819751, 111262694, 1274766160, 443224088, 298511866, 1025883608, 3806446537, 1145181785, 168956806, 3641502830, 3584813610, 1689216846, 3666258015, 3200248200, 1692713982, 2646376535, 4042768518, 1618508792, 1610833997, 3523052358, 4130873264, 2001055236, 3610705100, 2202168115, 4028541809, 2961195399, 1006657119, 2006996926, 3186142756, 1430667929, 3210227297, 1314452623, 4074634658, 4101304120, 2273951170, 1399257539, 3367210612, 3027628629, 1190975929, 2062231137, 2333990788, 2221543033, 2438960610, 1181637006, 548689776, 2362791313, 3372408396, 3104550113, 3145860560, 296247880, 1970579870, 3078560182, 3769228297, 1714227617, 3291629107, 3898220290, 166772364, 1251581989, 493813264, 448347421, 195405023, 2709975567, 677966185, 3703036547, 1463355134, 2715995803, 1338867538, 1343315457, 2802222074, 2684532164, 233230375, 2599980071, 2000651841, 3277868038, 1638401717, 4028070440, 3237316320, 6314154, 819756386, 300326615, 590932579, 1405279636, 3267499572, 3150704214, 2428286686, 3959192993, 3461946742, 1862657033, 1266418056, 963775037, 2089974820, 2263052895, 1917689273, 448879540, 3550394620, 3981727096, 150775221, 3627908307, 1303187396, 508620638, 2975983352, 2726630617, 1817252668, 1876281319, 1457606340, 908771278, 3720792119, 3617206836, 2455994898, 1729034894, 1080033504], [976866871, 3556439503, 2881648439, 1522871579, 1555064734, 1336096578, 3548522304, 2579274686, 3574697629, 3205460757, 3593280638, 3338716283, 3079412587, 564236357, 2993598910, 1781952180, 1464380207, 3163844217, 3332601554, 1699332808, 1393555694, 1183702653, 3581086237, 1288719814, 691649499, 2847557200, 2895455976, 3193889540, 2717570544, 1781354906, 1676643554, 2592534050, 3230253752, 1126444790, 2770207658, 2633158820, 2210423226, 2615765581, 2414155088, 3127139286, 673620729, 2805611233, 1269405062, 4015350505, 3341807571, 4149409754, 1057255273, 2012875353, 2162469141, 2276492801, 2601117357, 993977747, 3918593370, 2654263191, 753973209, 36408145, 2530585658, 25011837, 3520020182, 2088578344, 530523599, 2918365339, 1524020338, 1518925132, 3760827505, 3759777254, 1202760957, 3985898139, 3906192525, 674977740, 4174734889, 2031300136, 2019492241, 3983892565, 4153806404, 3822280332, 352677332, 2297720250, 60907813, 90501309, 3286998549, 1016092578, 2535922412, 2839152426, 457141659, 509813237, 4120667899, 652014361, 1966332200, 2975202805, 55981186, 2327461051, 676427537, 3255491064, 2882294119, 3433927263, 1307055953, 942726286, 933058658, 2468411793, 3933900994, 4215176142, 1361170020, 2001714738, 2830558078, 3274259782, 1222529897, 1679025792, 2729314320, 3714953764, 1770335741, 151462246, 3013232138, 1682292957, 1483529935, 471910574, 1539241949, 458788160, 3436315007, 1807016891, 3718408830, 978976581, 1043663428, 3165965781, 1927990952, 4200891579, 2372276910, 3208408903, 3533431907, 1412390302, 2931980059, 4132332400, 1947078029, 3881505623, 4168226417, 2941484381, 1077988104, 1320477388, 886195818, 18198404, 3786409000, 2509781533, 112762804, 3463356488, 1866414978, 891333506, 18488651, 661792760, 1628790961, 3885187036, 3141171499, 876946877, 2693282273, 1372485963, 791857591, 2686433993, 3759982718, 3167212022, 3472953795, 2716379847, 445679433, 3561995674, 3504004811, 3574258232, 54117162, 3331405415, 2381918588, 3769707343, 4154350007, 1140177722, 4074052095, 668550556, 3214352940, 367459370, 261225585, 2610173221, 4209349473, 3468074219, 3265815641, 314222801, 3066103646, 3808782860, 282218597, 3406013506, 3773591054, 379116347, 1285071038, 846784868, 2669647154, 3771962079, 3550491691, 2305946142, 453669953, 1268987020, 3317592352, 3279303384, 3744833421, 2610507566, 3859509063, 266596637, 3847019092, 517658769, 3462560207, 3443424879, 370717030, 4247526661, 2224018117, 4143653529, 4112773975, 2788324899, 2477274417, 1456262402, 2901442914, 1517677493, 1846949527, 2295493580, 3734397586, 2176403920, 1280348187, 1908823572, 3871786941, 846861322, 1172426758, 3287448474, 3383383037, 1655181056, 3139813346, 901632758, 1897031941, 2986607138, 3066810236, 3447102507, 1393639104, 373351379, 950779232, 625454576, 3124240540, 4148612726, 2007998917, 544563296, 2244738638, 2330496472, 2058025392, 1291430526, 424198748, 50039436, 29584100, 3605783033, 2429876329, 2791104160, 1057563949, 3255363231, 3075367218, 3463963227, 1469046755, 985887462]]\n    self._key = [1266315497, 3048417604, 3681880366, 3289982499, 2909710000, 1235738493, 2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449, 422970021, 1963543593]\n    self._p_new = self._p.copy()", "source": "blowfish_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: _swap", "output": "def _swap(self, a, b):\n    temp = a\n    a = b\n    b = temp\n    return (a, b)", "source": "blowfish_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: _driver", "output": "def _driver(self):\n    for i in range(0, 18):\n        self._p[i] = self._p[i] ^ self._key[i % 14]\n    k = 0\n    data = 0\n    for i in range(0, 9):\n        temp = self._encryption(data)\n        self._p[k] = temp >> 32\n        k += 1\n        self._p[k] = temp & 4294967295\n        k += 1\n        data = temp", "source": "blowfish_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: encrypt", "output": "def encrypt(self, data):\n    self._driver()\n    return self._encryption(data)", "source": "blowfish_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: decrypt", "output": "def decrypt(self, data):\n    return self._decryption(data)", "source": "blowfish_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: _encryption", "output": "def _encryption(self, data):\n    L = data >> 32\n    R = data & 4294967295\n    for i in range(0, 16):\n        L = self._p[i] ^ L\n        L1 = self._func(L)\n        R = R ^ self._func(L1)\n        L, R = self._swap(L, R)\n    L, R = self._swap(L, R)\n    L = L ^ self._p[17]\n    R = R ^ self._p[16]\n    encrypted = L << 32 ^ R\n    return encrypted", "source": "blowfish_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: _func", "output": "def _func(self, L):\n    temp = self._s[0][L >> 24]\n    temp = (temp + self._s[1][L >> 16 & 255]) % 2 ** 32\n    temp = temp ^ self._s[2][L >> 8 & 255]\n    temp = (temp + self._s[3][L & 255]) % 2 ** 32\n    return temp", "source": "blowfish_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: _decryption", "output": "def _decryption(self, data):\n    L = data >> 32\n    R = data & 4294967295\n    for i in range(17, 1, -1):\n        L = self._p[i] ^ L\n        L1 = self._func(L)\n        R = R ^ self._func(L1)\n        L, R = self._swap(L, R)\n    L, R = self._swap(L, R)\n    L = L ^ self._p[0]\n    R = R ^ self._p[1]\n    decrypted_data1 = L << 32 ^ R\n    return decrypted_data1", "source": "blowfish_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: __init__", "output": "def __init__(self):\n    self._plain_text = ''\n    self._key = 0\n    self._cipher_text = ''", "source": "caesar_cipher.py"}
{"instruction": "Implement a function for: :param plain_text: text to encrypt in caesar cipher (str)\n:param key: _key to encrypt the text (int)", "input": "Function name: encrypt", "output": "def encrypt(self, plain_text, key=3):\n    \"\"\"\n        :param plain_text: text to encrypt in caesar cipher (str)\n        :param key: _key to encrypt the text (int) (optional)\n        :return: encrypted text (str)\n        \"\"\"\n    self._plain_text = plain_text\n    self._key = key\n    self._cipher_text = ''\n    for char in plain_text:\n        if char == ' ':\n            self._cipher_text += char\n        elif char.isupper():\n            self._cipher_text += chr((ord(char) + key - 65) % 26 + 65)\n        else:\n            self._cipher_text += chr((ord(char) + key - 97) % 26 + 97)\n    return self._cipher_text", "source": "caesar_cipher.py"}
{"instruction": "Implement a function for: :param cipher_text: cipher text to decrypt (str)\n:param key: _key to decrypt the text (int) (optiona", "input": "Function name: decrypt", "output": "def decrypt(self, cipher_text, key=3):\n    \"\"\"\n        :param cipher_text: cipher text to decrypt (str)\n        :param key: _key to decrypt the text (int) (optional)\n        :return: decrypted text (str)\n        \"\"\"\n    self._cipher_text = cipher_text\n    self._key = key\n    self._plain_text = ''\n    for char in cipher_text:\n        if char == ' ':\n            self._plain_text += char\n        elif char.isupper():\n            self._plain_text += chr((ord(char) - key - 65) % 26 + 65)\n        else:\n            self._plain_text += chr((ord(char) - key - 97) % 26 + 97)\n    return self._plain_text", "source": "caesar_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: __init__", "output": "def __init__(self):\n    self._key = []\n    self._cipher_text = ''\n    self._plain_text = ''", "source": "hill_cipher.py"}
{"instruction": "Implement a function for:     This function will convert the message into matrix\n:param s: message (string)\n:return: matrix (l", "input": "Function name: _message_matrix", "output": "def _message_matrix(self, s):\n    \"\"\"\n            This function will convert the message into matrix\n        :param s: message (string)\n        :return: matrix (list)\n        \"\"\"\n    n = len(self._key)\n    s = s.replace(' ', '')\n    s = s.lower()\n    final_matrix = []\n    if len(s) % n != 0:\n        while len(s) % n != 0:\n            s = s + 'z'\n    for k in range(len(s) // n):\n        message_matrix = []\n        for i in range(n):\n            sub = []\n            for j in range(1):\n                sub.append(ord(s[i + n * k]) - ord('a'))\n            message_matrix.append(sub)\n        final_matrix.append(message_matrix)\n    return final_matrix", "source": "hill_cipher.py"}
{"instruction": "Implement a function for:     This function will get the cofactor of the matrix\n:param mat: matrix (list)\n:param temp: tempora", "input": "Function name: _getCofactor", "output": "@staticmethod\ndef _getCofactor(mat, temp, p, q, n):\n    \"\"\"\n            This function will get the cofactor of the matrix\n        :param mat: matrix (list)\n        :param temp: temporary matrix (list)\n        :param p: row (int)\n        :param q: column (int)\n        :param n: size of matrix (int)\n        :return: None\n        \"\"\"\n    i = 0\n    j = 0\n    for row in range(n):\n        for col in range(n):\n            if row != p and col != q:\n                temp[i][j] = mat[row][col]\n                j += 1\n                if j == n - 1:\n                    j = 0\n                    i += 1", "source": "hill_cipher.py"}
{"instruction": "Implement a function for:     This function will calculate the determinant of the matrix\n:param mat: matrix (list)\n:param n: s", "input": "Function name: _determinantOfMatrix", "output": "def _determinantOfMatrix(self, mat, n):\n    \"\"\"\n            This function will calculate the determinant of the matrix\n        :param mat: matrix (list)\n        :param n: size of matrix (int)\n        :return: determinant (int)\n        \"\"\"\n    D = 0\n    if n == 1:\n        return mat[0][0]\n    temp = [[0 for _ in range(n)] for _ in range(n)]\n    sign = 1\n    for f in range(n):\n        self._getCofactor(mat, temp, 0, f, n)\n        D += sign * mat[0][f] * self._determinantOfMatrix(temp, n - 1)\n        sign = -sign\n    return D", "source": "hill_cipher.py"}
{"instruction": "Implement a function for:     This function will check whether the matrix is invertible or not\n:param mat: matrix (list)\n:para", "input": "Function name: _isInvertible", "output": "def _isInvertible(self, mat, n):\n    \"\"\"\n            This function will check whether the matrix is invertible or not\n        :param mat: matrix (list)\n        :param n: size of matrix (int)\n        :return: True or False (bool)\n        \"\"\"\n    if self._determinantOfMatrix(mat, n) != 0:\n        return True\n    else:\n        return False", "source": "hill_cipher.py"}
{"instruction": "Implement a function for:     This function will multiply the key and message matrix and convert the result into character\n:pa", "input": "Function name: _multiply_and_convert", "output": "@staticmethod\ndef _multiply_and_convert(key, message):\n    \"\"\"\n            This function will multiply the key and message matrix and convert the result into character\n        :param key: key matrix (list)\n        :param message: message matrix (list)\n        :return: final matrix (list)\n        \"\"\"\n    res_num = [[0 for _ in range(len(message[0]))] for _ in range(len(key))]\n    for i in range(len(key)):\n        for j in range(len(message[0])):\n            for k in range(len(message)):\n                res_num[i][j] += key[i][k] * message[k][j]\n    res_alpha = [['' for _ in range(len(message[0]))] for _ in range(len(key))]\n    for i in range(len(key)):\n        for j in range(len(message[0])):\n            res_alpha[i][j] += chr(res_num[i][j] % 26 + 97)\n    return res_alpha", "source": "hill_cipher.py"}
{"instruction": "Implement a function for:     This function will calculate the modular inverse of the matrix\n:param a: matrix (list)\n:param m:", "input": "Function name: _modInverse", "output": "@staticmethod\ndef _modInverse(a, m):\n    \"\"\"\n            This function will calculate the modular inverse of the matrix\n        :param a: matrix (list)\n        :param m: size of matrix (int)\n        :return: modular inverse (list)\n        \"\"\"\n    a = a % m\n    for x in range(1, m):\n        if a * x % m == 1:\n            return x\n    return 1", "source": "hill_cipher.py"}
{"instruction": "Implement a function for:     This function will calculate the modular inverse of the matrix\n:param a: matrix (list)\n:param m:", "input": "Function name: _method", "output": "def _method(self, a, m):\n    \"\"\"\n            This function will calculate the modular inverse of the matrix\n        :param a: matrix (list)\n        :param m: size of matrix (int)\n        :return: modular inverse (list)\n        \"\"\"\n    if a > 0:\n        return a % m\n    else:\n        k = abs(a) // m + 1\n    return self._method(a + k * m, m)", "source": "hill_cipher.py"}
{"instruction": "Implement a function for: :param plain_text: plain text (string)\n:param key: key (list)\n:return: cipher text (string)", "input": "Function name: encrypt", "output": "def encrypt(self, plain_text, key):\n    \"\"\"\n        :param plain_text: plain text (string)\n        :param key: key (list)\n        :return: cipher text (string)\n        \"\"\"\n    self._cipher_text = ''\n    self._plain_text = plain_text\n    self._key = key\n    if self._isInvertible(self._key, len(self._key)):\n        pass\n    else:\n        raise Exception('Key is not invertible')\n    message = self._message_matrix(self._plain_text)\n    final_message = ''\n    for i in message:\n        sub = self._multiply_and_convert(self._key, i)\n        for j in sub:\n            for k in j:\n                final_message += k\n    return final_message", "source": "hill_cipher.py"}
{"instruction": "Implement a function for: :param cipher_text: cipher text (string)\n:param key: key (list)\n:return: plain text (string)", "input": "Function name: decrypt", "output": "def decrypt(self, cipher_text, key):\n    \"\"\"\n        :param cipher_text: cipher text (string)\n        :param key: key (list)\n        :return: plain text (string)\n        \"\"\"\n    self._cipher_text = cipher_text\n    self._key = key\n    self._plain_text = ''\n    A = np.array(self._key)\n    det = np.linalg.det(A)\n    adjoint = det * np.linalg.inv(A)\n    if det != 0:\n        convert_det = self._modInverse(int(det), 26)\n        adjoint = adjoint.tolist()\n        for i in range(len(adjoint)):\n            for j in range(len(adjoint[i])):\n                adjoint[i][j] = round(adjoint[i][j])\n                adjoint[i][j] = self._method(adjoint[i][j], 26)\n        adjoint = np.array(adjoint)\n        inverse = convert_det * adjoint\n        inverse = inverse.tolist()\n        for i in range(len(inverse)):\n            for j in range(len(inverse[i])):\n                inverse[i][j] = inverse[i][j] % 26\n        message = self._message_matrix(self._cipher_text)\n        plain_text = ''\n        for i in message:\n            sub = self._multiply_and_convert(inverse, i)\n            for j in sub:\n                for k in j:\n                    plain_text += k\n        return plain_text\n    else:\n        raise Exception('Key is not invertible')", "source": "hill_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: __init__", "output": "def __init__(self):\n    self._message = ''", "source": "img_steganography.py"}
{"instruction": "Implement a function for: :param data: data to be encrypted\n:param image_path: path of image (str)\n:param new_img_path: path o", "input": "Function name: encrypt", "output": "def encrypt(self, data, image_path, new_img_path='encrypt_data_image.png'):\n    \"\"\"\n        :param data: data to be encrypted\n        :param image_path: path of image (str)\n        :param new_img_path: path of new image (str) (optional)\n        :return: None (image is saved in the same directory)\n        \"\"\"\n    self._message = data\n    img = cv2.imread(image_path)\n    self._message = [format(ord(i), '08b') for i in data]\n    _, width, _ = img.shape\n    PixReq = len(self._message) * 3\n    RowReq = PixReq / width\n    RowReq = math.ceil(RowReq)\n    count = 0\n    charCount = 0\n    for i in range(RowReq + 1):\n        while count < width and charCount < len(data):\n            char = self._message[charCount]\n            charCount += 1\n            for index_k, k in enumerate(char):\n                if k == '1' and img[i][count][index_k % 3] % 2 == 0 or (k == '0' and img[i][count][index_k % 3] % 2 == 1):\n                    img[i][count][index_k % 3] -= 1\n                if index_k % 3 == 2:\n                    count += 1\n                if index_k == 7:\n                    if charCount * 3 < PixReq and img[i][count][2] % 2 == 1:\n                        img[i][count][2] -= 1\n                    if charCount * 3 >= PixReq and img[i][count][2] % 2 == 0:\n                        img[i][count][2] -= 1\n                    count += 1\n        count = 0\n    cv2.imwrite(new_img_path, img)", "source": "img_steganography.py"}
{"instruction": "Implement a function for: :param img_path: path of image (str)\n:return: decrypted data (str)", "input": "Function name: decrypt", "output": "def decrypt(self, img_path):\n    \"\"\"\n        :param img_path: path of image (str)\n        :return: decrypted data (str)\n        \"\"\"\n    self._message = ''\n    img = cv2.imread(img_path)\n    data = []\n    stop = False\n    for _, i in enumerate(img):\n        i.tolist()\n        for index_j, j in enumerate(i):\n            if index_j % 3 == 2:\n                data.append(bin(j[0])[-1])\n                data.append(bin(j[1])[-1])\n                if bin(j[2])[-1] == '1':\n                    stop = True\n                    break\n            else:\n                data.append(bin(j[0])[-1])\n                data.append(bin(j[1])[-1])\n                data.append(bin(j[2])[-1])\n        if stop:\n            break\n    temp_message = []\n    for i in range(int((len(data) + 1) / 8)):\n        temp_message.append(data[i * 8:i * 8 + 8])\n    temp_message = [chr(int(''.join(i), 2)) for i in temp_message]\n    self._message = str(''.join(temp_message))\n    return self._message", "source": "img_steganography.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: __init__", "output": "def __init__(self):\n    self._morse = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', '0': '-----', ', ': '--..--', '.': '.-.-.-', '?': '..--..', '/': '-..-.', '-': '-....-', '(': '-.--.', ')': '-.--.-'}\n    self._morse_inv = {v: k for k, v in self._morse.items()}\n    self._plain_text = ''\n    self._encrypted_text = ''", "source": "morse.py"}
{"instruction": "Implement a function for: :param plain_text: Plain text to be encrypted (str)\n:return: Encrypted text (str)", "input": "Function name: encrypt", "output": "def encrypt(self, plain_text):\n    \"\"\"\n        :param plain_text: Plain text to be encrypted (str)\n        :return: Encrypted text (str)\n        \"\"\"\n    self._plain_text = plain_text.upper()\n    self._encrypted_text = ''\n    for letter in self._plain_text:\n        if letter != ' ':\n            self._encrypted_text += self._morse[letter] + ' '\n        else:\n            self._encrypted_text += ' '\n    return self._encrypted_text", "source": "morse.py"}
{"instruction": "Implement a function for: :param encrypted_text: Encrypted text to be decrypted (str)\n:return: Decrypted text (str)", "input": "Function name: decrypt", "output": "def decrypt(self, encrypted_text):\n    \"\"\"\n        :param encrypted_text: Encrypted text to be decrypted (str)\n        :return: Decrypted text (str)\n        \"\"\"\n    self._encrypted_text = encrypted_text\n    self._encrypted_text += ' '\n    self._plain_text = ''\n    temp = ''\n    i = 0\n    for letter in self._encrypted_text:\n        if letter != ' ':\n            i = 0\n            temp += letter\n        else:\n            i += 1\n            if i == 2:\n                self._plain_text += ' '\n            else:\n                self._plain_text += self._morse_inv[temp]\n                temp = ''\n    return self._plain_text", "source": "morse.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: __init__", "output": "def __init__(self):\n    self._plain_text = ''\n    self._cipher_text = ''\n    self._key = ''\n    self._key_matrix = ''", "source": "playfair_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: _key_generation", "output": "def _key_generation(self):\n    main = string.ascii_lowercase.replace('j', '.')\n    self._key = self._key.lower()\n    self._key_matrix = ['' for i in range(5)]\n    i = 0\n    j = 0\n    for c in self._key:\n        if c in main:\n            self._key_matrix[i] += c\n            main = main.replace(c, '.')\n            j += 1\n            if j > 4:\n                i += 1\n                j = 0\n    for c in main:\n        if c != '.':\n            self._key_matrix[i] += c\n            j += 1\n            if j > 4:\n                i += 1\n                j = 0", "source": "playfair_cipher.py"}
{"instruction": "Implement a function for: :param plain_text: plain text to encrypt(str)\n:param key: key to encrypt the plain text(str)\n:return", "input": "Function name: encrypt", "output": "def encrypt(self, plain_text, key):\n    \"\"\"\n        :param plain_text: plain text to encrypt(str)\n        :param key: key to encrypt the plain text(str)\n        :return: encrypted text(str)\n        \"\"\"\n    self._plain_text = plain_text\n    self._key = key\n    self._cipher_text = ''\n    plain_text_pairs = []\n    cipher_text_pairs = []\n    self._key_generation()\n    text = self._plain_text.replace(' ', '')\n    text = text.lower()\n    i = 0\n    while i < len(text):\n        a = text[i]\n        if i + 1 == len(text):\n            b = 'x'\n        else:\n            b = text[i + 1]\n        if a != b:\n            plain_text_pairs.append(a + b)\n            i += 2\n        else:\n            plain_text_pairs.append(a + 'x')\n            i += 1\n    for pair in plain_text_pairs:\n        flag = False\n        for row in self._key_matrix:\n            if pair[0] in row and pair[1] in row:\n                j0 = row.find(pair[0])\n                j1 = row.find(pair[1])\n                cipher_text_pair = row[(j0 + 1) % 5] + row[(j1 + 1) % 5]\n                cipher_text_pairs.append(cipher_text_pair)\n                flag = True\n        if flag:\n            continue\n        for j in range(5):\n            col = ''.join([self._key_matrix[i][j] for i in range(5)])\n            if pair[0] in col and pair[1] in col:\n                i0 = col.find(pair[0])\n                i1 = col.find(pair[1])\n                cipher_text_pair = col[(i0 + 1) % 5] + col[(i1 + 1) % 5]\n                cipher_text_pairs.append(cipher_text_pair)\n                flag = True\n        if flag:\n            continue\n        i0 = 0\n        i1 = 0\n        j0 = 0\n        j1 = 0\n        for i in range(5):\n            row = self._key_matrix[i]\n            if pair[0] in row:\n                i0 = i\n                j0 = row.find(pair[0])\n            if pair[1] in row:\n                i1 = i\n                j1 = row.find(pair[1])\n        cipher_text_pair = self._key_matrix[i0][j1] + self._key_matrix[i1][j0]\n        cipher_text_pairs.append(cipher_text_pair)\n    return ''.join(cipher_text_pairs)", "source": "playfair_cipher.py"}
{"instruction": "Implement a function for: :param cipher_text: cipher text to decrypt (str)\n:param key: key to decrypt the cipher text (str)\n:r", "input": "Function name: decrypt", "output": "def decrypt(self, cipher_text, key):\n    \"\"\"\n        :param cipher_text: cipher text to decrypt (str)\n        :param key: key to decrypt the cipher text (str)\n        :return: decrypted text (str)\n        \"\"\"\n    self._cipher_text = cipher_text.lower()\n    self._key = key\n    self._plain_text = ''\n    plain_text_pairs = []\n    cipher_text_pairs = []\n    self._key_generation()\n    i = 0\n    while i < len(self._cipher_text):\n        a = self._cipher_text[i]\n        b = self._cipher_text[i + 1]\n        cipher_text_pairs.append(a + b)\n        i += 2\n    for pair in cipher_text_pairs:\n        flag = False\n        for row in self._key_matrix:\n            if pair[0] in row and pair[1] in row:\n                j0 = row.find(pair[0])\n                j1 = row.find(pair[1])\n                plain_text_pair = row[(j0 + 4) % 5] + row[(j1 + 4) % 5]\n                plain_text_pairs.append(plain_text_pair)\n                flag = True\n        if flag:\n            continue\n        for j in range(5):\n            col = ''.join([self._key_matrix[i][j] for i in range(5)])\n            if pair[0] in col and pair[1] in col:\n                i0 = col.find(pair[0])\n                i1 = col.find(pair[1])\n                plain_text_pair = col[(i0 + 4) % 5] + col[(i1 + 4) % 5]\n                plain_text_pairs.append(plain_text_pair)\n                flag = True\n        if flag:\n            continue\n        i0 = 0\n        i1 = 0\n        j0 = 0\n        j1 = 0\n        for i in range(5):\n            row = self._key_matrix[i]\n            if pair[0] in row:\n                i0 = i\n                j0 = row.find(pair[0])\n            if pair[1] in row:\n                i1 = i\n                j1 = row.find(pair[1])\n        plain_text_pair = self._key_matrix[i0][j1] + self._key_matrix[i1][j0]\n        plain_text_pairs.append(plain_text_pair)\n    return ''.join(plain_text_pairs)", "source": "playfair_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: __init__", "output": "def __init__(self):\n    SQUARE = [['a', 'b', 'c', 'd', 'e'], ['f', 'g', 'h', 'i', 'k'], ['l', 'm', 'n', 'o', 'p'], ['q', 'r', 's', 't', 'u'], ['v', 'w', 'x', 'y', 'z']]\n    self.SQUARE = np.array(SQUARE)\n    self._plaintext = ''\n    self._ciphertext = ''", "source": "polybius_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: _letter_to_numbers", "output": "def _letter_to_numbers(self, letter):\n    index1, index2 = np.where(self.SQUARE == letter)\n    indexes = np.concatenate([index1 + 1, index2 + 1])\n    return indexes", "source": "polybius_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: _numbers_to_letter", "output": "def _numbers_to_letter(self, index1: int, index2: int) -> str:\n    return self.SQUARE[index1 - 1, index2 - 1]", "source": "polybius_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: encrypt", "output": "def encrypt(self, plaintext):\n    self._plaintext = plaintext.replace('j', 'i').lower()\n    self._ciphertext = ''\n    for letter_index in range(len(self._plaintext)):\n        if self._plaintext[letter_index] != ' ':\n            numbers = self._letter_to_numbers(self._plaintext[letter_index])\n            self._ciphertext = self._ciphertext + str(numbers[0]) + str(numbers[1])\n        elif self._plaintext[letter_index] == ' ':\n            self._ciphertext = self._ciphertext + ' '\n    return self._ciphertext", "source": "polybius_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: decrypt", "output": "def decrypt(self, ciphertext):\n    self._ciphertext = ciphertext.replace(' ', '  ')\n    self._plaintext = ''\n    for numbers_index in range(int(len(self._ciphertext) / 2)):\n        if self._ciphertext[numbers_index * 2] != ' ':\n            index1 = self._ciphertext[numbers_index * 2]\n            index2 = self._ciphertext[numbers_index * 2 + 1]\n            letter = self._numbers_to_letter(int(index1), int(index2))\n            self._plaintext = self._plaintext + letter\n        elif self._ciphertext[numbers_index * 2] == ' ':\n            self._plaintext = self._plaintext + ' '\n    return self._plaintext", "source": "polybius_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: __init__", "output": "def __init__(self):\n    self._key = ''\n    self._ciphertext = ''\n    self._plaintext = ''", "source": "rail_fence.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: _sequence", "output": "@staticmethod\ndef _sequence(key):\n    arr = []\n    i = 0\n    while i < key - 1:\n        arr.append(i)\n        i += 1\n    while i > 0:\n        arr.append(i)\n        i -= 1\n    return arr", "source": "rail_fence.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: encrypt", "output": "def encrypt(self, plaintext, key):\n    self._plaintext = plaintext.replace(' ', '').lower()\n    self._ciphertext = ''\n    self._key = key\n    L = self._sequence(self._key)\n    temp = L\n    while len(self._plaintext) > len(L):\n        L = L + temp\n    for _ in range(len(L) - len(self._plaintext)):\n        L.pop()\n    num = 0\n    while num < self._key:\n        for i in range(L.count(num)):\n            self._ciphertext = self._ciphertext + self._plaintext[L.index(num)]\n            L[L.index(num)] = self._key\n        num += 1\n    return self._ciphertext", "source": "rail_fence.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: decrypt", "output": "def decrypt(self, ciphertext, key):\n    self._ciphertext = ciphertext.lower()\n    self._plaintext = ''\n    self._key = key\n    L = self._sequence(self._key)\n    temp = L\n    while len(self._ciphertext) > len(L):\n        L = L + temp\n    for i in range(len(L) - len(self._ciphertext)):\n        L.pop()\n    temp = sorted(L)\n    for i in L:\n        k = temp.index(i)\n        temp[k] = self._key\n        self._plaintext += self._ciphertext[k]\n    return self._plaintext", "source": "rail_fence.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: __init__", "output": "def __init__(self):\n    self._key = ''\n    self._ciphertext = ''\n    self._plaintext = ''", "source": "vernam_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: encrypt", "output": "def encrypt(self, plain_text, key):\n    self._plaintext = plain_text.replace(' ', '').lower()\n    self._key = key.replace(' ', '').lower()\n    self._ciphertext = ''\n    if len(self._plaintext) != len(self._key):\n        raise Exception('Length of plain text and key must be same')\n    else:\n        for i in range(len(self._plaintext)):\n            k1 = ord(self._plaintext[i]) - 97\n            k2 = ord(self._key[i]) - 97\n            s = chr((k1 + k2) % 26 + 97)\n            self._ciphertext += s\n        return self._ciphertext", "source": "vernam_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: decrypt", "output": "def decrypt(self, cipher_text, key):\n    self._ciphertext = cipher_text.replace(' ', '').lower()\n    self._key = key.replace(' ', '').lower()\n    self._plaintext = ''\n    if len(self._ciphertext) != len(self._key):\n        raise Exception('Length of cipher text and key must be same')\n    else:\n        for i in range(len(self._ciphertext)):\n            k1 = ord(self._ciphertext[i]) - 97\n            k2 = ord(self._key[i]) - 97\n            s = chr((k1 - k2 + 26) % 26 + 97)\n            self._plaintext += s\n        return self._plaintext", "source": "vernam_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: __init__", "output": "def __init__(self):\n    self._plain_text = []\n    self._key = ''\n    self._cipher_text = []", "source": "vigenere_cipher.py"}
{"instruction": "Implement a function for: :param plain_text: plain text to be encrypted (str)\n:param key: key to encrypt plain text (str)\n:ret", "input": "Function name: encrypt", "output": "def encrypt(self, plain_text, key):\n    \"\"\"\n        :param plain_text: plain text to be encrypted (str)\n        :param key: key to encrypt plain text (str)\n        :return: encrypted text (str)\n        \"\"\"\n    index = 0\n    self._cipher_text = ''\n    self._plain_text = plain_text.lower()\n    self._key = key.lower()\n    for c in self._plain_text:\n        if c in string.ascii_lowercase:\n            off = ord(self._key[index]) - ord('a')\n            encrypt_num = (ord(c) - ord('a') + off) % 26\n            encrypt = chr(encrypt_num + ord('a'))\n            self._cipher_text += encrypt\n            index = (index + 1) % len(self._key)\n        else:\n            self._cipher_text += c\n    return self._cipher_text", "source": "vigenere_cipher.py"}
{"instruction": "Implement a function for: :param cipher_text: cipher text to be decrypted (str)\n:param key: key to decrypt cipher text (str)\n:", "input": "Function name: decrypt", "output": "def decrypt(self, cipher_text, key):\n    \"\"\"\n        :param cipher_text: cipher text to be decrypted (str)\n        :param key: key to decrypt cipher text (str)\n        :return: decrypted text (str)\n        \"\"\"\n    index = 0\n    self._plain_text = ''\n    self._cipher_text = cipher_text.lower()\n    self._key = key.lower()\n    for c in self._cipher_text:\n        if c in string.ascii_lowercase:\n            off = ord(self._key[index]) - ord('a')\n            positive_off = 26 - off\n            decrypt = chr((ord(c) - ord('a') + positive_off) % 26 + ord('a'))\n            self._plain_text += decrypt\n            index = (index + 1) % len(self._key)\n        else:\n            self._plain_text += c\n    return self._plain_text", "source": "vigenere_cipher.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: main", "output": "def main():\n    blockSize = 16\n    cbcKey = '140b41b22a29beb4061bda66b6747e14'\n    ctrKey = '36f18357be4dbd77f050515c73fcf9f2'\n    cbcCipherText1 = '4ca00ff4c898d61e1edbf1800618fb2828a226d160dad07883d04e008a7897ee2e4b7465d5290d0c0e6c6822236e1daafb94ffe0c5da05d9476be028ad7c1d81'\n    cbcCipherText2 = '5b68629feb8606f9a6667670b75b38a5b4832d0f26e1ab7da33249de7d4afc48e713ac646ace36e872ad5fb8a512428a6e21364b0c374df45503473c5242a253'\n    ctrCipherText1 = '69dda8455c7dd4254bf353b773304eec0ec7702330098ce7f7520d1cbbb20fc388d1b0adb5054dbd7370849dbf0b88d393f252e764f1f5f7ad97ef79d59ce29f5f51eeca32eabedd9afa9329'\n    ctrCipherText2 = '770b80259ec33beb2561358a9f2dc617e46218c0a53cbeca695ae45faa8952aa0e311bde9d4e01726d3184c34451'\n    cbcPlainText1 = cbcDecryption(cbcKey, cbcCipherText1, blockSize)\n    cbcPlainText2 = cbcDecryption(cbcKey, cbcCipherText2, blockSize)\n    ctrPlainText1 = ctrDecryption(ctrKey, ctrCipherText1, blockSize)\n    ctrPlainText2 = ctrDecryption(ctrKey, ctrCipherText2, blockSize)\n    print('\\nAnswers  : \\n')\n    print('CBC Plain Text 1 : ' + codecs.decode(cbcPlainText1, 'utf-8'))\n    print('CBC Plain Text 2 : ' + codecs.decode(cbcPlainText2, 'utf-8'))\n    print('CTR Plain Text 1 : ' + codecs.decode(ctrPlainText1, 'utf-8'))\n    print('CTR Plain Text 2 : ' + codecs.decode(ctrPlainText2, 'utf-8'))\n    print('\\n')", "source": "AESCbcAndCtr.py"}
{"instruction": "Implement a function for: Function to decrypt the ciphertext encypted using the input key and AES CTR mode.\nInputs are the key", "input": "Function name: ctrDecryption", "output": "def ctrDecryption(ctrKey, ctrCipherText, blockSize):\n    \"\"\"Function to decrypt the ciphertext encypted using the input key and AES CTR mode.\n       Inputs are the key, ciphertext and the block size.\"\"\"\n    key = codecs.decode(ctrKey, 'hex')\n    ciphertextAndIV = codecs.decode(ctrCipherText, 'hex')\n    IV = ciphertextAndIV[:blockSize]\n    ciphertext = ciphertextAndIV[blockSize:]\n    ctr = Counter.new(blockSize * 8, initial_value=int(codecs.encode(IV, 'hex'), 16))\n    aesEngine = AES.new(key, AES.MODE_CTR, counter=ctr)\n    paddedStr = aesEngine.decrypt(ciphertext)\n    return paddedStr", "source": "AESCbcAndCtr.py"}
{"instruction": "Implement a function for: Function to decrypt the ciphertext encypted using the input key and AES CTR mode.\nInputs are the key", "input": "Function name: cbcDecryption", "output": "def cbcDecryption(cbcKey, cbcCipherText, blockSize):\n    \"\"\"Function to decrypt the ciphertext encypted using the input key and AES CTR mode.\n       Inputs are the key, ciphertext and the block size.\"\"\"\n    key = codecs.decode(cbcKey, 'hex')\n    ciphertextAndIV = codecs.decode(cbcCipherText, 'hex')\n    IV = ciphertextAndIV[:blockSize]\n    ciphertext = ciphertextAndIV[blockSize:]\n    aesEngine = AES.new(key, AES.MODE_CBC, IV)\n    paddedStr = aesEngine.decrypt(ciphertext)\n    paddingAmount = ord(paddedStr[len(paddedStr) - 1:])\n    return paddedStr[:-paddingAmount]", "source": "AESCbcAndCtr.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: main", "output": "def main():\n    print()\n    plaintext = input('Enter the plaintext : ').encode()\n    key = input('Enter key (must be less than 16 symbols and should consist of only alphabets & numbers) : ')\n    print()\n    if len(key) > 16:\n        print('Invalid Key. Key too long.')\n        return\n    for symbol in key:\n        if ord(symbol) > 255:\n            print('Invalid Key. Please use only latin alphabet and numbers.')\n            return\n    encryptedBytes = []\n    temp = []\n    for byte in plaintext:\n        temp.append(byte)\n        if len(temp) == 16:\n            Encrypted16Bytes = AES128Encryption(temp, key)\n            encryptedBytes.extend(Encrypted16Bytes)\n            temp = []\n    emptySpaces = None\n    if 0 < len(temp) < 16:\n        emptySpaces = 16 - len(temp)\n        for i in range(emptySpaces - 1):\n            temp.append(0)\n        temp.append(1)\n        Encrypted16Bytes = AES128Encryption(temp, key)\n        encryptedBytes.extend(Encrypted16Bytes)\n    encryptedMessage = bytes(encryptedBytes)\n    print('Encrypted ciphertext is (in bytes) : ', encryptedMessage)\n    decryptedBytes = []\n    temp = []\n    for byte in encryptedMessage:\n        temp.append(byte)\n        if len(temp) == 16:\n            Decrypted16Bytes = AES128Decryption(temp, key)\n            decryptedBytes.extend(Decrypted16Bytes)\n            temp = []\n    if emptySpaces != None:\n        decryptedMessage = bytes(decryptedBytes[:-emptySpaces])\n    else:\n        decryptedMessage = bytes(decryptedBytes)\n    print('Decrypted plaintext is (in bytes) : ', decryptedMessage)\n    print()", "source": "program.py"}
{"instruction": "Implement a function for: Function to implement AES Encryption Algorithm. Number of bytes should be equal to 16.", "input": "Function name: AES128Encryption", "output": "def AES128Encryption(plaintextBytes, key):\n    \"\"\"Function to implement AES Encryption Algorithm. Number of bytes should be equal to 16.\"\"\"\n    state = [[] for j in range(4)]\n    for row in range(4):\n        for column in range(noOfColumns):\n            state[row].append(plaintextBytes[row + 4 * column])\n    keySchedule = keyExpansion(key)\n    round = 0\n    state = addRoundKey(state, keySchedule, round)\n    for round in range(1, noOfRounds):\n        state = subBytes(state, False)\n        state = shiftRows(state, False)\n        state = mixColumns(state, False)\n        state = addRoundKey(state, keySchedule, round)\n    state = subBytes(state, False)\n    state = shiftRows(state, False)\n    state = addRoundKey(state, keySchedule, round + 1)\n    output = [None for i in range(4 * noOfColumns)]\n    for row in range(4):\n        for column in range(noOfColumns):\n            output[row + 4 * column] = state[row][column]\n    return output", "source": "program.py"}
{"instruction": "Implement a function for: Function to implement AES Decryption Algorithm. Number of bytes should be equal to 16.", "input": "Function name: AES128Decryption", "output": "def AES128Decryption(ciphertextBytes, key):\n    \"\"\"Function to implement AES Decryption Algorithm. Number of bytes should be equal to 16.\"\"\"\n    state = [[] for i in range(noOfColumns)]\n    for row in range(4):\n        for column in range(noOfColumns):\n            state[row].append(ciphertextBytes[row + 4 * column])\n    keySchedule = keyExpansion(key)\n    state = addRoundKey(state, keySchedule, noOfRounds)\n    round = noOfRounds - 1\n    for round in range(round, 0, -1):\n        state = shiftRows(state, True)\n        state = subBytes(state, True)\n        state = addRoundKey(state, keySchedule, round)\n        state = mixColumns(state, True)\n    round -= 1\n    state = shiftRows(state, True)\n    state = subBytes(state, True)\n    state = addRoundKey(state, keySchedule, round)\n    output = [None for i in range(4 * noOfColumns)]\n    for row in range(4):\n        for column in range(noOfColumns):\n            output[row + 4 * column] = state[row][column]\n    return output", "source": "program.py"}
{"instruction": "Implement a function for: Function to use Sbox or Inverse Sbox to determine subBytes value in the algorithm", "input": "Function name: subBytes", "output": "def subBytes(state, inverse):\n    \"\"\"Function to use Sbox or Inverse Sbox to determine subBytes value in the algorithm\"\"\"\n    box = Sbox\n    if inverse == True:\n        box = inverseSbox\n    for i in range(len(state)):\n        for j in range(len(state[i])):\n            row = state[i][j] // 16\n            column = state[i][j] % 16\n            boxElement = box[16 * row + column]\n            state[i][j] = boxElement\n    return state", "source": "program.py"}
{"instruction": "Implement a function for: Function to shift rows in the state matrix as done in the AES algorithm.", "input": "Function name: shiftRows", "output": "def shiftRows(state, inverse):\n    \"\"\"Function to shift rows in the state matrix as done in the AES algorithm.\"\"\"\n    count = 1\n    if inverse == True:\n        for i in range(1, noOfColumns):\n            state[i] = rightShift(state[i], count)\n            count += 1\n    else:\n        for i in range(1, noOfColumns):\n            state[i] = leftShift(state[i], count)\n            count += 1\n    return state", "source": "program.py"}
{"instruction": "Implement a function for: Left shift an array count times.", "input": "Function name: leftShift", "output": "def leftShift(array, count):\n    \"\"\"Left shift an array count times.\"\"\"\n    return array[count:] + array[:count]", "source": "program.py"}
{"instruction": "Implement a function for: Right shift an array count times.", "input": "Function name: rightShift", "output": "def rightShift(array, count):\n    \"\"\"Right shift an array count times.\"\"\"\n    return array[-count:] + array[:-count]", "source": "program.py"}
{"instruction": "Implement a function for: Mixing columns with the Galois field attributes as done in the AES algorithm.\nMultiplication of matr", "input": "Function name: mixColumns", "output": "def mixColumns(state, inverse):\n    \"\"\"Mixing columns with the Galois field attributes as done in the AES algorithm.\n       Multiplication of matrices takes place here.\"\"\"\n    for i in range(noOfColumns):\n        if inverse == True:\n            s0 = multiplyBy0x0e(state[0][i]) ^ multiplyBy0x0b(state[1][i]) ^ multiplyBy0x0d(state[2][i]) ^ multiplyBy0x09(state[3][i])\n            s1 = multiplyBy0x09(state[0][i]) ^ multiplyBy0x0e(state[1][i]) ^ multiplyBy0x0b(state[2][i]) ^ multiplyBy0x0d(state[3][i])\n            s2 = multiplyBy0x0d(state[0][i]) ^ multiplyBy0x09(state[1][i]) ^ multiplyBy0x0e(state[2][i]) ^ multiplyBy0x0b(state[3][i])\n            s3 = multiplyBy0x0b(state[0][i]) ^ multiplyBy0x0d(state[1][i]) ^ multiplyBy0x09(state[2][i]) ^ multiplyBy0x0e(state[3][i])\n        else:\n            s0 = multiplyBy0x02(state[0][i]) ^ multiplyBy0x03(state[1][i]) ^ state[2][i] ^ state[3][i]\n            s1 = state[0][i] ^ multiplyBy0x02(state[1][i]) ^ multiplyBy0x03(state[2][i]) ^ state[3][i]\n            s2 = state[0][i] ^ state[1][i] ^ multiplyBy0x02(state[2][i]) ^ multiplyBy0x03(state[3][i])\n            s3 = multiplyBy0x03(state[0][i]) ^ state[1][i] ^ state[2][i] ^ multiplyBy0x02(state[3][i])\n        state[0][i] = s0\n        state[1][i] = s1\n        state[2][i] = s2\n        state[3][i] = s3\n    return state", "source": "program.py"}
{"instruction": "Implement a function for: Funtion to make list of keys for addRoundKey.", "input": "Function name: keyExpansion", "output": "def keyExpansion(key):\n    \"\"\"Funtion to make list of keys for addRoundKey.\"\"\"\n    keySymbols = [ord(symbol) for symbol in key]\n    if len(keySymbols) < 4 * noOfWordsInKey:\n        for i in range(4 * noOfWordsInKey - len(keySymbols)):\n            keySymbols.append(1)\n    keySchedule = [[] for i in range(4)]\n    for row in range(4):\n        for column in range(noOfWordsInKey):\n            keySchedule[row].append(keySymbols[row + 4 * column])\n    for column in range(noOfWordsInKey, noOfColumns * (noOfRounds + 1)):\n        if column % noOfWordsInKey == 0:\n            temp = [keySchedule[row][column - 1] for row in range(1, 4)]\n            temp.append(keySchedule[0][column - 1])\n            for j in range(len(temp)):\n                SboxRow = temp[j] // 16\n                SboxColumn = temp[j] % 16\n                SboxElement = Sbox[16 * SboxRow + SboxColumn]\n                temp[j] = SboxElement\n            for row in range(4):\n                s = keySchedule[row][column - 4] ^ temp[row] ^ RCON[row][int(column / noOfWordsInKey - 1)]\n                keySchedule[row].append(s)\n        else:\n            for row in range(4):\n                s = keySchedule[row][column - 4] ^ keySchedule[row][column - 1]\n                keySchedule[row].append(s)\n    return keySchedule", "source": "program.py"}
{"instruction": "Implement a function for: That transformation combines State and KeySchedule together. Xor\nof State and RoundSchedule(part of ", "input": "Function name: addRoundKey", "output": "def addRoundKey(state, keySchedule, round):\n    \"\"\"That transformation combines State and KeySchedule together. Xor\n    of State and RoundSchedule(part of KeySchedule).\n    \"\"\"\n    for column in range(noOfWordsInKey):\n        s0 = state[0][column] ^ keySchedule[0][noOfColumns * round + column]\n        s1 = state[1][column] ^ keySchedule[1][noOfColumns * round + column]\n        s2 = state[2][column] ^ keySchedule[2][noOfColumns * round + column]\n        s3 = state[3][column] ^ keySchedule[3][noOfColumns * round + column]\n        state[0][column] = s0\n        state[1][column] = s1\n        state[2][column] = s2\n        state[3][column] = s3\n    return state", "source": "program.py"}
{"instruction": "Implement a function for: Function to multiply by 0x02 in Galois Space.", "input": "Function name: multiplyBy0x02", "output": "def multiplyBy0x02(number):\n    \"\"\"Function to multiply by 0x02 in Galois Space.\"\"\"\n    if number < 128:\n        result = number << 1\n    else:\n        result = number << 1 ^ 27\n    result = result % 256\n    return result", "source": "program.py"}
{"instruction": "Implement a function for: Function to multiply by 0x03 in Galois Space.", "input": "Function name: multiplyBy0x03", "output": "def multiplyBy0x03(number):\n    \"\"\"Function to multiply by 0x03 in Galois Space.\"\"\"\n    return multiplyBy0x02(number) ^ number", "source": "program.py"}
{"instruction": "Implement a function for: Function to multiply by 0x09 in Galois Space.", "input": "Function name: multiplyBy0x09", "output": "def multiplyBy0x09(number):\n    \"\"\"Function to multiply by 0x09 in Galois Space.\"\"\"\n    return multiplyBy0x02(multiplyBy0x02(multiplyBy0x02(number))) ^ number", "source": "program.py"}
{"instruction": "Implement a function for: Function to multiply by 0x0b in Galois Space.", "input": "Function name: multiplyBy0x0b", "output": "def multiplyBy0x0b(number):\n    \"\"\"Function to multiply by 0x0b in Galois Space.\"\"\"\n    return multiplyBy0x02(multiplyBy0x02(multiplyBy0x02(number))) ^ multiplyBy0x02(number) ^ number", "source": "program.py"}
{"instruction": "Implement a function for: Function to multiply by 0x0d in Galois Space.", "input": "Function name: multiplyBy0x0d", "output": "def multiplyBy0x0d(number):\n    \"\"\"Function to multiply by 0x0d in Galois Space.\"\"\"\n    return multiplyBy0x02(multiplyBy0x02(multiplyBy0x02(number))) ^ multiplyBy0x02(multiplyBy0x02(number)) ^ number", "source": "program.py"}
{"instruction": "Implement a function for: Function to multiply by 0x0e in Galois Space.", "input": "Function name: multiplyBy0x0e", "output": "def multiplyBy0x0e(number):\n    \"\"\"Function to multiply by 0x0e in Galois Space.\"\"\"\n    return multiplyBy0x02(multiplyBy0x02(multiplyBy0x02(number))) ^ multiplyBy0x02(multiplyBy0x02(number)) ^ multiplyBy0x02(number)", "source": "program.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: main", "output": "def main():\n    print()\n    plaintext = input('Enter the message to be encrypted : ')\n    key = int(input('Enter the key (a number) : '))\n    print()\n    ciphertext = caesarEncryption(plaintext, key)\n    plaintext = caesarDecryption(ciphertext, key)\n    print()\n    print('Encrypted ciphertext is : ', ciphertext)\n    print('Decrypted plaintext is  : ', plaintext)\n    print()\n    return", "source": "program.py"}
{"instruction": "Implement a function for: Function to encrypt the plaintext using Caesar Encryption.", "input": "Function name: caesarEncryption", "output": "def caesarEncryption(plaintext, key):\n    \"\"\"Function to encrypt the plaintext using Caesar Encryption.\"\"\"\n    ciphertext = ''\n    for letter in plaintext:\n        ascii = ord(letter)\n        if letter.isalpha():\n            temp = ascii + key\n            if temp > 90 and letter.isupper() or (temp > 122 and letter.islower()):\n                ciphertext += chr(temp - 26)\n            else:\n                ciphertext += chr(temp)\n    return ciphertext", "source": "program.py"}
{"instruction": "Implement a function for: Function to decrypt the ciphertext using Caesar Decryption.", "input": "Function name: caesarDecryption", "output": "def caesarDecryption(ciphertext, key):\n    \"\"\"Function to decrypt the ciphertext using Caesar Decryption.\"\"\"\n    plaintext = ''\n    for letter in ciphertext:\n        ascii = ord(letter)\n        if letter.isalpha():\n            temp = ascii - key\n            if temp < 65 and letter.isupper() or (temp < 97 and letter.islower()):\n                plaintext += chr(temp + 26)\n            else:\n                plaintext += chr(temp)\n    return plaintext", "source": "program.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: main", "output": "def main():\n    print()\n    plaintext = input('Enter the message to be encrypted : ')\n    key = input('Enter a key of 8 length (64-bits) (characters or numbers only) : ')\n    print()\n    if len(key) != 8:\n        print('Invalid Key. Key should be of 8 length (8 bytes).')\n        return\n    isPaddingRequired = len(plaintext) % 8 != 0\n    ciphertext = DESEncryption(key, plaintext, isPaddingRequired)\n    plaintext = DESDecryption(key, ciphertext, isPaddingRequired)\n    print()\n    print('Encrypted Ciphertext is : %r ' % ciphertext)\n    print('Decrypted plaintext is  : ', plaintext)\n    print()", "source": "program.py"}
{"instruction": "Implement a function for: Function for DES Encryption.", "input": "Function name: DESEncryption", "output": "def DESEncryption(key, text, padding):\n    \"\"\"Function for DES Encryption.\"\"\"\n    if padding == True:\n        text = addPadding(text)\n    ciphertext = DES(text, key, padding, True)\n    return ciphertext", "source": "program.py"}
{"instruction": "Implement a function for: Function for DES Decryption.", "input": "Function name: DESDecryption", "output": "def DESDecryption(key, text, padding):\n    \"\"\"Function for DES Decryption.\"\"\"\n    plaintext = DES(text, key, padding, False)\n    if padding == True:\n        return removePadding(plaintext)\n    return plaintext", "source": "program.py"}
{"instruction": "Implement a function for: Function to implement DES Algorithm.", "input": "Function name: DES", "output": "def DES(text, key, padding, isEncrypt):\n    \"\"\"Function to implement DES Algorithm.\"\"\"\n    isDecrypt = not isEncrypt\n    keys = generateKeys(key)\n    plaintext8byteBlocks = nSplit(text, 8)\n    result = []\n    for block in plaintext8byteBlocks:\n        block = stringToBitArray(block)\n        block = permutation(block, initialPermutationMatrix)\n        leftBlock, rightBlock = nSplit(block, 32)\n        temp = None\n        for i in range(16):\n            expandedRightBlock = expand(rightBlock, expandMatrix)\n            if isEncrypt == True:\n                temp = xor(keys[i], expandedRightBlock)\n            elif isDecrypt == True:\n                temp = xor(keys[15 - i], expandedRightBlock)\n            temp = SboxSubstitution(temp)\n            temp = permutation(temp, eachRoundPermutationMatrix)\n            temp = xor(leftBlock, temp)\n            leftBlock = rightBlock\n            rightBlock = temp\n        result += permutation(rightBlock + leftBlock, finalPermutationMatrix)\n    finalResult = bitArrayToString(result)\n    return finalResult", "source": "program.py"}
{"instruction": "Implement a function for: Function to generate keys for different rounds of DES.", "input": "Function name: generateKeys", "output": "def generateKeys(key):\n    \"\"\"Function to generate keys for different rounds of DES.\"\"\"\n    keys = []\n    key = stringToBitArray(key)\n    key = permutation(key, keyPermutationMatrix1)\n    leftBlock, rightBlock = nSplit(key, 28)\n    for i in range(16):\n        leftBlock, rightBlock = leftShift(leftBlock, rightBlock, SHIFT[i])\n        temp = leftBlock + rightBlock\n        keys.append(permutation(temp, keyPermutationMatrix2))\n    return keys", "source": "program.py"}
{"instruction": "Implement a function for: Function to substitute all the bytes using Sbox.", "input": "Function name: SboxSubstitution", "output": "def SboxSubstitution(bitArray):\n    \"\"\"Function to substitute all the bytes using Sbox.\"\"\"\n    blocks = nSplit(bitArray, 6)\n    result = []\n    for i in range(len(blocks)):\n        block = blocks[i]\n        row = int(str(block[0]) + str(block[5]), 2)\n        column = int(''.join([str(x) for x in block[1:-1]]), 2)\n        sboxValue = SboxesArray[i][row][column]\n        binVal = binValue(sboxValue, 4)\n        result += [int(bit) for bit in binVal]\n    return result", "source": "program.py"}
{"instruction": "Implement a function for: Function to add padding according to PKCS5 standard.", "input": "Function name: addPadding", "output": "def addPadding(text):\n    \"\"\"Function to add padding according to PKCS5 standard.\"\"\"\n    paddingLength = 8 - len(text) % 8\n    text += chr(paddingLength) * paddingLength\n    return text", "source": "program.py"}
{"instruction": "Implement a function for: Function to remove padding from plaintext according to PKCS5.", "input": "Function name: removePadding", "output": "def removePadding(data):\n    \"\"\"Function to remove padding from plaintext according to PKCS5.\"\"\"\n    paddingLength = ord(data[-1])\n    return data[:-paddingLength]", "source": "program.py"}
{"instruction": "Implement a function for: Function to expand the array using table.", "input": "Function name: expand", "output": "def expand(array, table):\n    \"\"\"Function to expand the array using table.\"\"\"\n    return [array[element - 1] for element in table]", "source": "program.py"}
{"instruction": "Implement a function for: Function to do permutation on the array using table.", "input": "Function name: permutation", "output": "def permutation(array, table):\n    \"\"\"Function to do permutation on the array using table.\"\"\"\n    return [array[element - 1] for element in table]", "source": "program.py"}
{"instruction": "Implement a function for: Function to left shift the arrays by n.", "input": "Function name: leftShift", "output": "def leftShift(list1, list2, n):\n    \"\"\"Function to left shift the arrays by n.\"\"\"\n    return (list1[n:] + list1[:n], list2[n:] + list2[:n])", "source": "program.py"}
{"instruction": "Implement a function for: Function to split a list into chunks of size n.", "input": "Function name: nSplit", "output": "def nSplit(list, n):\n    \"\"\"Function to split a list into chunks of size n.\"\"\"\n    return [list[i:i + n] for i in range(0, len(list), n)]", "source": "program.py"}
{"instruction": "Implement a function for: Function to return the XOR of two lists.", "input": "Function name: xor", "output": "def xor(list1, list2):\n    \"\"\"Function to return the XOR of two lists.\"\"\"\n    return [element1 ^ element2 for element1, element2 in zip(list1, list2)]", "source": "program.py"}
{"instruction": "Implement a function for: Function to return the binary value as a string of given size.", "input": "Function name: binValue", "output": "def binValue(val, bitSize):\n    \"\"\"Function to return the binary value as a string of given size.\"\"\"\n    binVal = bin(val)[2:] if isinstance(val, int) else bin(ord(val))[2:]\n    while len(binVal) < bitSize:\n        binVal = '0' + binVal\n    return binVal", "source": "program.py"}
{"instruction": "Implement a function for: Funtion to convert a string into a list of bits.", "input": "Function name: stringToBitArray", "output": "def stringToBitArray(text):\n    \"\"\"Funtion to convert a string into a list of bits.\"\"\"\n    bitArray = []\n    for letter in text:\n        binVal = binValue(letter, 8)\n        binValArr = [int(x) for x in list(binVal)]\n        bitArray += binValArr\n    return bitArray", "source": "program.py"}
{"instruction": "Implement a function for: Function to convert a list of bits to string.", "input": "Function name: bitArrayToString", "output": "def bitArrayToString(array):\n    \"\"\"Function to convert a list of bits to string.\"\"\"\n    byteChunks = nSplit(array, 8)\n    stringBytesList = []\n    stringResult = ''\n    for byte in byteChunks:\n        bitsList = []\n        for bit in byte:\n            bitsList += str(bit)\n        stringBytesList.append(''.join(bitsList))\n    result = ''.join([chr(int(stringByte, 2)) for stringByte in stringBytesList])\n    return result", "source": "program.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: main", "output": "def main():\n    global target, ciphertexts\n    bytesTargetRepresentation = codecs.decode(target, 'hex')\n    stringTargetRepresentation = ''\n    for byte in bytesTargetRepresentation:\n        stringTargetRepresentation += chr(byte)\n    answers = []\n    for key in ciphertexts:\n        cipher = ciphertexts[key]\n        ciphertextBytesRepresentation = codecs.decode(cipher, 'hex')\n        ciphertextStringRepresentation = ''\n        for byte in ciphertextBytesRepresentation:\n            ciphertextStringRepresentation += chr(byte)\n        hexXorResult = strxor(stringTargetRepresentation, ciphertextStringRepresentation)\n        guessedString = ''\n        for g in hexXorResult:\n            if ord(g) >= 65 and ord(g) <= 90 or (ord(g) >= 97 and ord(g) <= 122):\n                guessedString += g\n            else:\n                guessedString += '*'\n        answers.append(guessedString)\n    resultHeuristic(answers)", "source": "manytimepass.py"}
{"instruction": "Implement a function for: Function to compute the most probabble answer based on the number of occurences\nof letters at corres", "input": "Function name: resultHeuristic", "output": "def resultHeuristic(answers):\n    \"\"\"Function to compute the most probabble answer based on the number of occurences\n       of letters at corresponding positions.\"\"\"\n    maxLenCandidates = []\n    for i in answers:\n        maxLenCandidates.append(len(i))\n        print(i)\n    maxLength = max(maxLenCandidates)\n    heuristicResult = ''\n    for j in range(maxLength):\n        listOfAlphabets = []\n        for i in answers:\n            try:\n                if ord(i[j]) >= 65 and ord(i[j]) <= 90 or (ord(i[j]) >= 97 and ord(i[j]) <= 122):\n                    listOfAlphabets.append(i[j])\n            except:\n                continue\n        distinctElements = []\n        for element in listOfAlphabets:\n            if element in distinctElements:\n                continue\n            else:\n                distinctElements.append(element)\n        if len(distinctElements) > 3 or listOfAlphabets == []:\n            heuristicResult += ' '\n        else:\n            heuristicResult += max(listOfAlphabets, key=listOfAlphabets.count)\n    heuristicResult = ''.join((c.lower() if c.isupper() else c.upper() for c in heuristicResult))\n    print('\\nAnswer obtained : \\n' + heuristicResult + '\\n')\n    print('Original answer : \\nThe secret message is : When using a stream cipher never use the key more than once\\n')", "source": "manytimepass.py"}
{"instruction": "Implement a function for: Function to compute xor of two strings of different lengths. Inputs are the strings to be xored.", "input": "Function name: strxor", "output": "def strxor(a, b):\n    \"\"\"Function to compute xor of two strings of different lengths. Inputs are the strings to be xored.\"\"\"\n    if len(a) > len(b):\n        return ''.join([chr(ord(x) ^ ord(y)) for x, y in zip(a[:len(b)], b)])\n    else:\n        return ''.join([chr(ord(x) ^ ord(y)) for x, y in zip(a, b[:len(a)])])", "source": "manytimepass.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: main", "output": "def main():\n    blockSize = 1024\n    checkFile = 'check.mp4'\n    verifyHash = '03c08f4ee0b576fe319338139c045c89c3e8e9409633bea29442e21425006ea8'\n    print('\\nThe last hash (h0) to be checked for file ' + checkFile + ' is: ' + verifyHash)\n    targetFile = 'target.mp4'\n    checkHash = computeLastHashh0(checkFile, blockSize)\n    targetHash = computeLastHashh0(targetFile, blockSize)\n    print('\\nRESULTS : \\n')\n    if checkHash == verifyHash:\n        print('\\nThe last hash (h0) to be checked for file ' + checkFile + ' is correct.')\n    print('The last hash (h0) of MP4 File ' + checkFile + ' is : ' + checkHash + '\\n')\n    print('The last hash (h0) of MP4 File ' + targetFile + ' is : ' + targetHash + '\\n')", "source": "SHA256HashVerification.py"}
{"instruction": "Implement a function for: Funtion to compute the last hash of a file using SHA-256. Inputs are the file\nand the block size.", "input": "Function name: computeLastHashh0", "output": "def computeLastHashh0(filePath, blockSize):\n    \"\"\"Funtion to compute the last hash of a file using SHA-256. Inputs are the file\n       and the block size.\"\"\"\n    lastHash = ''\n    for blockData in readBlocksFromEnd(filePath, blockSize):\n        SHA256Engine = SHA256.new()\n        if lastHash != '':\n            SHA256Engine.update(blockData)\n            SHA256Engine.update(lastHash)\n        else:\n            SHA256Engine.update(blockData)\n        lastHash = SHA256Engine.digest()\n    lastHash = codecs.encode(lastHash, 'hex')\n    lastHash = codecs.decode(lastHash, 'utf-8')\n    return lastHash", "source": "SHA256HashVerification.py"}
{"instruction": "Implement a function for: Generator function to get the blocks of information one at a time from the\nfile to be read in bytes.", "input": "Function name: readBlocksFromEnd", "output": "def readBlocksFromEnd(filePath, blockSize):\n    \"\"\"Generator function to get the blocks of information one at a time from the\n       file to be read in bytes. Inputs are the file path and the block size.\"\"\"\n    fileSize = os.path.getsize(filePath)\n    file = open(filePath, 'rb')\n    blockNumberFromEnd = 0\n    lastBlockSize = fileSize % blockSize\n    lastPosition = fileSize\n    readEndPosition = lastPosition\n    while readEndPosition > 0:\n        if blockNumberFromEnd == 0:\n            size = lastBlockSize\n        else:\n            size = blockSize\n        readStartPosition = readEndPosition - size\n        file.seek(readStartPosition)\n        data = file.read(blockSize)\n        blockNumberFromEnd += 1\n        readEndPosition -= size\n        yield data", "source": "SHA256HashVerification.py"}
{"instruction": "Implement a function for: No description", "input": "Function name: main", "output": "def main():\n    print()\n    plaintext = input('Enter the plaintext : ')\n    key = input('Enter the key (length should be >= length of plaintext) : ')\n    print()\n    alphabets = 'abcdefghijklmnopqrstuvwxyz'.upper()\n    for alphabet in alphabets:\n        mappingsDict[alphabet] = ord(alphabet) - 65\n    plaintext = plaintext.upper()\n    key = key.upper()\n    if len(key) < len(plaintext):\n        print(errorMessage)\n    else:\n        ciphertext = vernamEncryption(plaintext, key)\n        plaintext = vernamDecryption(ciphertext, key)\n        print()\n        print('Encrypted ciphertext is : ', ciphertext)\n        print('Decrypted plaintext is  : ', plaintext)\n        print()\n    return", "source": "program.py"}
{"instruction": "Implement a function for: Function to encrypt the plaintext using Vernam Encryption.", "input": "Function name: vernamEncryption", "output": "def vernamEncryption(plaintext, key):\n    \"\"\"Function to encrypt the plaintext using Vernam Encryption.\"\"\"\n    ciphertext = ''\n    for i in range(len(plaintext)):\n        ptLetter = plaintext[i]\n        keyLetter = key[i]\n        sum = mappingsDict[ptLetter] + mappingsDict[keyLetter]\n        if sum >= 26:\n            sum -= 26\n        ciphertext += chr(sum + 65)\n    return ciphertext", "source": "program.py"}
{"instruction": "Implement a function for: Function to decrypt the ciphertext using Vernam Decryption.", "input": "Function name: vernamDecryption", "output": "def vernamDecryption(ciphertext, key):\n    \"\"\"Function to decrypt the ciphertext using Vernam Decryption.\"\"\"\n    plaintext = ''\n    for i in range(len(ciphertext)):\n        ctLetter = ciphertext[i]\n        keyLetter = key[i]\n        diff = mappingsDict[ctLetter] - mappingsDict[keyLetter]\n        if diff < 0:\n            diff += 26\n        plaintext += chr(diff + 65)\n    return plaintext", "source": "program.py"}
